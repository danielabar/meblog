---
title: "Rails Feature Test Solved by Regex"
featuredImage: "../images/rails-feature-test-regex-patrick-tomasso-QMDap1TAu0g-unsplash.jpg"
description: "An example where regex was a good solution for a Rails feature test."
date: "2021-11-07"
category: "rails"
---

If you’ve been programming for awhile, you’ve probably encountered regular expressions (regex), and more specifically, this saying:

> Some people, when confronted with a problem, think “I know, I'll use regular expressions.” Now they have two problems.

Not sure as to the origin of this saying, but there's some discussion about it [here](http://regex.info/blog/2006-09-15/247). Personally, I approach the use of regex in my code with some trepidation, as they can be difficult to read, and I prefer to leave clean, easy to read code for future developers (including myself) who may be maintaining the code.

However, sometimes it is the right choice, and this post will walk through an example, where using a regular expression was useful in expressing an expectation in a feature test for a Rails project, plus a nice Ruby way of writing the regex that makes it very legible.

## The Problem

The application I’m working on allows users to setup multi-factor authentication. The last screen of the setup displays a recovery code that the user can use in the event that they get locked out of their account. This code is a series of 16 randomly generated numbers and letters, displayed in chunks of 4, each separated by a space for legibility. Here's an example of what the recovery codes look like:

```
1f08 6a11 b093 8fd6
```

After a PR got merged that made some changes to the multi-factor auth flow, a bug was introduced where the recovery code was no longer being displayed. The user would still get the screen instructing them to save the recovery code, but where the code should be displayed was a blank.

Investigation revealed that the recovery code was still being generated by the server and persisted in the database, but a UI bug was preventing it from being displayed. The fix was straightforward, however, this application has a very thorough suite of feature tests (implemented with Cucumber and Capybara) and I was surprised that one of the tests had not caught this bug.

## Feature Test

Turns out there was a feature test that runs through the multi-factor auth steps, but it only verified that the user landed on the recovery screen by verifying the page title. It did not verify that the recovery code was actually displayed. As part of fixing this bug, this test had to be enhanced to also verify the display of the recovery code.

Here is a portion of the markup that displays the recovery code:

```html
<p>Code: <strong>1f08 6a11 b093 8fd6</strong></p>
```

To make it easier to test, I first added a `data-test` attribute to the element containing the recovery code:

```html
<p>Code: <strong data-test="recovery-code">1f08 6a11 b093 8fd6</strong></p>
```

Next I needed to add a step to the existing feature test to retrieve the element containing the recovery code by `data-test` selector and verify its contents. Capybara's [have_selector](https://github.com/teamcapybara/capybara#querying) RSpec matcher is useful for finding an element by selector and text value. For example, given the following markup:

```html
<div data-test="message">
  Hello
</div>
```

Then a feature test could select this element and verify its contents as follows:

```ruby
expect(page).to have_selector("div[data-test='message']", text: "Hello")
```

## Regex

In the case of the recovery code, the text value is randomly generated so it won’t work to have a static value in the text option for the `have_selector` matcher. This is where a regex is a good solution. It turns out, the text option also accepts a regular expression. So the test to verify that the recovery code is displayed needs to look something like this:

```ruby
expect(page).to have_selector("strong[data-test='recovery-code']", text: /TBD/)
```

<aside class="markdown-aside">
It's not obvious from the Capybara docs that there even is a text option or that it also accepts a regex. This Stackoverflow Q&A goes through the source to determine the <a class="markdown-link" href="https://stackoverflow.com/questions/23961636/what-are-the-options-to-capybaras-have-selector">supported options</a>.
</aside>

To match the recovery code accurately, the regex needs to match on any 4 letters or numbers, followed by a space, followed by any 4 letters or numbers, up to 4 chunks of these. To match any letter or number the `\w` shorthand can be used, which is equivalent to `[0-9a-zA-Z_]`. To specify 4 of these, use `\w{4}`. To match the whitespace, `\s` is used. Putting this all together:

```ruby
expect(page).to have_selector("strong[data-test='recovery-code']", text: /\w{4}\s\w{4}\s\w{4}\s\w{4}/)
```

While this certainly works, it's difficult to read. Fortunately, Ruby has an alternate syntax for specifying a regex that is not whitespace sensitive. It involves wrapping the regex in `%r{...}` and then adding the `x` modifier which makes it ignore whitespace. This allows the regex to be split up among multiple lines, and it can even have comments beside each line. So the previous line becomes:

```ruby
recovery_code_format = %r{
  \w{4}     # Any 4 characters
  \s        # Space
  \w{4}     # Any 4 characters
  \s        # Space
  \w{4}     # Any 4 characters
  \s        # Space
  \w{4}     # Any 4 characters
}x
expect(page).to have_selector("strong[data-test='recovery-code']", text: recovery_code_format)
```

This is much more legible and easier to maintain should the recovery code format change in the future.