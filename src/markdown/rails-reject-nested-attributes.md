---
title: "Reject Nested Attributes in Rails"
featuredImage: "../images/reject-nested-attributespawel-czerwinski-rfkXGUbYnS8-unsplash.jpg"
description: "Learn how to use Rails accepts_nested_attributes_for and reject_if options to create flexible forms that handle nested models with optional associations."
date: "2024-11-01"
category: "rails"
related:
  - "They Don't All Have To Be ActiveRecord Models"
  - "Rails Strong Params for GET Request"
  - "Understanding ActiveRecord Dependent Options"
---

When building a web application for a  relational data model, handling nested models in a single form submission is a common requirement. Rails provides a powerful solution with the ActiveRecord method `accepts_nested_attributes_for`. This feature enables us to create a form that captures both the main model and its associated model(s), streamlining the user experience. However, this can sometimes lead to issues with validation, as we'll explore in this post. We'll see how the `reject_if` option comes to the rescue, enabling us to create a flexible form that can handle optional associated models.

## Initial Setup

Let's start with a typical example: We have a User and Address model, where a User can have an Address, and the Address belongs to the user (i.e. the `user_id` foreign key is on the `addresses` table):

```ruby
# == Schema Information
#
# Table name: users
#
#  id         :integer          not null, primary key
#  email      :string           not null
#  name       :string           not null
#  created_at :datetime         not null
#  updated_at :datetime         not null
#
# Indexes
#
#  index_users_on_email  (email) UNIQUE
#
class User < ApplicationRecord
  has_one :address, dependent: :destroy

  validates :name, presence: true
  validates :email, presence: true, uniqueness: true
end
```

```ruby
# == Schema Information
#
# Table name: addresses
#
#  id             :integer          not null, primary key
#  city           :string           not null
#  country        :string           not null
#  state_province :string           not null
#  street         :string           not null
#  created_at     :datetime         not null
#  updated_at     :datetime         not null
#  user_id        :integer          not null
#
# Indexes
#
#  index_addresses_on_user_id  (user_id)
#
# Foreign Keys
#
#  user_id  (user_id => users.id)
#
class Address < ApplicationRecord
  belongs_to :user

  validates :street, :city, :state_province, :country, presence: true
end
```

The default `UsersController` generated by the Rails [scaffold](https://www.rubyguides.com/2020/03/rails-scaffolding/) command looks like this:

```ruby
class UsersController < ApplicationController
  before_action :set_user, only: %i[show edit update destroy]

  # GET /users or /users.json
  def index
    @users = User.all
  end

  # GET /users/1 or /users/1.json
  def show; end

  # GET /users/new
  def new
    @user = User.new
  end

  # GET /users/1/edit
  def edit
  end

  # POST /users or /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        format.html { redirect_to user_url(@user), notice: "User was successfully created." }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /users/1 or /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to user_url(@user), notice: "User was successfully updated." }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /users/1 or /users/1.json
  def destroy
    @user.destroy!

    respond_to do |format|
      format.html { redirect_to users_url, notice: "User was successfully destroyed." }
      format.json { head :no_content }
    end
  end

  private

  # Use callbacks to share common setup or constraints between actions.
  def set_user
    @user = User.find(params[:id])
  end

  # Only allow a list of trusted parameters through.
  def user_params
    params.require(:user).permit(:name, :email)
  end
end
```

And here is the users form partial `app/views/users/_form.html.erb` that handles both new User creation and editing existing Users:

```erb
<%= form_with(model: user, class: "contents") do |form| %>
  <% if user.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(user.errors.count, "error") %> prohibited this user from being saved:</h2>
      <ul>
        <% user.errors.each do |error| %>
          <li><%= error.full_message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div>
    <%= form.label :name %>
    <%= form.text_field :name%>
  </div>

  <div>
    <%= form.label :email %>
    <%= form.text_field :email%>
  </div>

  <div>
    <%= form.submit%>
  </div>
<% end %>
```

## Introducing accepts_nested_attributes_for

Now suppose we want to enhance the User form, to also contain the Address fields, such that when the form is submitted, the address automatically gets associated with the user. Here are the changes to make this happen.

Start by updating the `User` model, to declare that it accepts nested attributes for the address model:

```ruby
class User < ApplicationRecord
  has_one :address, dependent: :destroy

  # === NEW ===
  accepts_nested_attributes_for :address

  validates :name, presence: true
  validates :email, presence: true, uniqueness: true
end
```

The [accepts_nested_attribute_for](https://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html#method-i-accepts_nested_attributes_for) method defines an attribute writer for the specified association. This enabled a parent model to accept and update attributes for its associated child model. In the example above, we're declaring that from the User model, it can populate attributes for the Address model.

Next we need to modify the `new` method in the `UsersController` to build a potential address for the user using the `build_address` method:

```ruby
class UsersController < ApplicationController
  # ...
  def new
    @user = User.new
    @user.build_address # Build a new address for the user
  end
  # ...
end
```

Now the user form partial `app/views/users/_form.html.erb` can be updated to use the [fields_for](https://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-fields_for) helper to render the address fields for the user:

```erb
<%= form_with(model: user, class: "contents") do |form| %>
  <%# Validation errors... %>

  <div>
    <%= form.label :name %>
    <%= form.text_field :name%>
  </div>

  <div>
    <%= form.label :email %>
    <%= form.text_field :email%>
  </div>

  <%# === NEW SECTION START === %>
  <%= form.fields_for :address do |address_fields| %>
    <div>
      <%= address_fields.label :street %>
      <%= address_fields.text_field :street %>
    </div>

    <div>
      <%= address_fields.label :city %>
      <%= address_fields.text_field :city %>
    </div>

    <div>
      <%= address_fields.label :state_province %>
      <%= address_fields.text_field :state_province %>
    </div>

    <div>
      <%= address_fields.label :country %>
      <%= address_fields.text_field :country %>
    </div>
    <%# === NEW SECTION END === %>

    <div>
      <%= form.submit%>
    </div>
  <% end %>
<% end %>
```

The `fields_for` helper yields a block, similar to `form_with`, but it does not generate the `<form>...</form>` tags. This makes it suitable for specifying additional model objects in the same form.

WIP...
Explain the concept and its benefits
Provide an example with User has_one Address
Show how to use form.fields_for in the erb template

## The Problem: Validation Issues
Explain how validation rules can cause issues when not all associated models are required
Show an example of how this can lead to errors

## Solution: reject_if Option
Introduce the reject_if option and its purpose
Explain the :all_blank option and how it works
Provide an example of how to use reject_if with :all_blank

## Experimenting with Variations
Explore using a Proc with reject_if
Show how to use a Symbol pointing to a custom method in the User model

## Additional Notes and Considerations
Discuss how Rails generates hidden fields for associated models when editing
Explain how updates work with accepts_nested_attributes_for and form.fields_for
From https://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-fields_for:
> Note that fields_for will automatically generate a hidden field to store the ID of the record if it responds to persisted?. There are circumstances where this hidden field is not needed and you can pass include_id: false to prevent fields_for from rendering it automatically.

## Conclusion

This post has covered the very useful combination of `accepts_nested_attributes_for` and `reject_if` options in Rails. Together, these enable creation of flexible forms to handle nested models with optional associations, streamlining data entry. Now, take the next step and explore the variations and possibilities offered by these features to enhance your Rails applications!


## TODO
* WIP: main content
* link to demo repo
* official guides links for scaffold command? https://guides.rubyonrails.org/command_line.html
* edit
* aside about dynamic `build_...` method added by AR association: https://guides.rubyonrails.org/association_basics.html#methods-added-by-belongs-to-build-association-attributes
  * The build_address method is dynamically generated by Rails based on the has_one association declaration. This is a feature of Active Record's association builder. According to the official Rails guides, when you declare a has_one association, Rails automatically generates a builder method for that association. In this case, the build_address method is generated because of the has_one :address declaration.
Here are the relevant sections in the official Rails guides:
[Rails Guides: Active Record Associations]((link unavailable))
[Rails Guides: Active Record Association Builder]((link unavailable))
The API documentation for the has_one method also mentions the generation of the builder method:
[ActiveRecord::Associations::ClassMethods#has_one]((link unavailable))
Note that the build_address method is not explicitly documented in the API docs, as it is dynamically generated based on the association name. However, the guides and API documentation explain the general behavior of association builders and the generation of these methods.
* Diff between https://api.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html#method-i-fields_for and https://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-fields_for
