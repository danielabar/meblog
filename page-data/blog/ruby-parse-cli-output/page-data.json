{"componentChunkName":"component---src-templates-post-js","path":"/blog/ruby-parse-cli-output/","result":{"data":{"markdownRemark":{"html":"<p class=\"markdown-para\">This post will show you how to chain together multiple Ruby one-liners to parse command line output from system commands, and execute further system commands using the output from the previous command. Why would you want to do this? Consider the following scenario.</p>\n<p class=\"markdown-para\">Our team is using <a href=\"../nomad-tips-and-tricks\" class=\"markdown-link\">Nomad</a> to deploy a Rails application which runs with multiple instances of Puma and a Sidekiq server for background jobs. Each of these runs in Docker containers, all orchestrated by Nomad. We frequently need to run a shell in one of the containers to perform some troubleshooting. This requires running two commands.</p>\n<p class=\"markdown-para\">The first command gets the status of the Nomad job that runs Puma and Sidekiq. This command displays a list of allocations, which can be used to get at the Docker containers running the multiple instances of Puma and Sidekiq. Then a second command is needed to run a shell in a container, which requires the allocation ID of the container to run in. It looks like this:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">### FIRST COMMAND ###</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Get status of job `myapp` which runs Puma and Sidekiq</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$ nomad job status myapp</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Output of the status command</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Name          = myapp</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Type          = service</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Status        = running</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">Allocations</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">ID        Node ID   Task Group  Version  Desired  Status   Created    Modified</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">1afe229e  3008ce71  puma        123      run      running  2d20h ago  2d20h ago</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">ff39a003  3008ce71  puma        123      run      running  2d20h ago  2d20h ago</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">9bd5fa5d  5163a6cb  puma        123      run      running  2d20h ago  2d20h ago</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">e5353169  3008ce71  sidekiq     123      run      running  2d20h ago  2d20h ago</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">### SECOND COMMAND ###</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Run a shell in the sidekiq container, given Allocation ID from the previous command</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$ nomad alloc </span><span class=\"mtk9\">exec</span><span class=\"mtk1\"> -i -t -task sidekiq e5353169  /bin/bash</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Now we&#39;re in the sidekiq container</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">root@d60b9bcf4827:/myapp#</span></span></span></code></pre>\n<h2 class=\"markdown-subtitle\" id=\"the-problem\" style=\"position:relative;\"><a href=\"#the-problem\" aria-label=\"the problem permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Problem</h2>\n<p class=\"markdown-para\">Not only does this require two commands, but it also requires visually scanning the output of the status command to find the Allocation ID of the sidekiq container, then copying it to paste into the second command to run a shell in this container.  If this was required only once in a while, it would be fine to leave as is. But this is a task everyone on our team has to do frequently, and the manual effort was getting tedious. Since we're a Ruby shop, it was a natural fit to use Ruby to help with automating this.</p>\n<h2 class=\"markdown-subtitle\" id=\"script-solution\" style=\"position:relative;\"><a href=\"#script-solution\" aria-label=\"script solution permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Script Solution</h2>\n<p class=\"markdown-para\">Here is the script that allows the above workflow to be completed in one step, with no copy/pasting. It's placed in the <code>script</code> directory in the project root. Don't worry if it seems hard to understand, all will be explained.</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">#!/bin/bash</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># USAGE: ./script/run-nomad-shell.sh</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Parse sidekiq allocation ID from status output, storing it in $id variable</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">id=</span><span class=\"mtk6\">$(echo $(ruby -e &quot;</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\">nomad status myapp</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\"> =~ /^(\\w+)\\s+\\w+\\s+sidekiq.*/&quot; -e &quot;puts </span><span class=\"mtk4\">\\$</span><span class=\"mtk6\">1&quot;))</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Run a shell in sidekiq allocation parsed from previous step</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">nomad alloc </span><span class=\"mtk9\">exec</span><span class=\"mtk1\"> -i -t -task sidekiq $id /bin/bash</span></span></span></code></pre>\n<p class=\"markdown-para\">The first line uses a chain of ruby one-liners to execute the <code>nomad status</code> command, and parse it with regex to capture the sidekiq container allocation ID. The result of the regex capture group gets stored in a script variable <code>id</code>. This variable is then used in the second command to run a shell in the container.</p>\n<p class=\"markdown-para\">The second command is fairly straightforward, but the first command looks a little hairy, let's break it down.</p>\n<h3 class=\"markdown-sub-subtitle\" id=\"ruby-one-liners\" style=\"position:relative;\"><a href=\"#ruby-one-liners\" aria-label=\"ruby one liners permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ruby One Liners</h3>\n<p class=\"markdown-para\">First thing you might notice in this line from the script is that ruby is being executed, but with a <code>-e</code> flag:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">id=</span><span class=\"mtk6\">$(echo $(ruby -e &quot;</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\">nomad status myapp</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\"> =~ /^(\\w+)\\s+\\w+\\s+sidekiq.*/&quot; -e &quot;puts </span><span class=\"mtk4\">\\$</span><span class=\"mtk6\">1&quot;))</span></span></span></code></pre>\n<p class=\"markdown-para\">Normally when running a Ruby program, the file name containing the source code is passed to the <code>ruby</code> command line:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">ruby my_program.rb</span></span></code></pre>\n<p class=\"markdown-para\">However, for short programs (aka one liners), the <code>-e</code> flag can be used to pass some code directly as an argument:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">ruby -e &quot;puts &#39;One Liner!&#39;&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"># Outputs: One Liner!</span></span></code></pre>\n<p class=\"markdown-para\">Further reading on Ruby <a href=\"https://learnbyexample.github.io/learn_ruby_oneliners/one-liner-introduction.html\" class=\"markdown-link\">one liners</a>.</p>\n<h3 class=\"markdown-sub-subtitle\" id=\"system-commands\" style=\"position:relative;\"><a href=\"#system-commands\" aria-label=\"system commands permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>System Commands</h3>\n<p class=\"markdown-para\">Another thing to notice in this line from the script is the use of backticks surrounding <code>nomad status myapp</code>:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">id=</span><span class=\"mtk6\">$(echo $(ruby -e &quot;</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\">nomad status myapp</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\"> =~ /^(\\w+)\\s+\\w+\\s+sidekiq.*/&quot; -e &quot;puts </span><span class=\"mtk4\">\\$</span><span class=\"mtk6\">1&quot;))</span></span></span></code></pre>\n<p class=\"markdown-para\">Backticks are used in Ruby to run system commands. For example, the <code>date</code> command in *nix displays the system date and time:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$ date</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Outputs something like: Mon 21 Feb 2022 10:51:36 EST</span></span></span></code></pre>\n<p class=\"markdown-para\">This can also be run within a Ruby program, to try it out, launch an IRB console:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk6\">`date`</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk6\">&quot;Mon 21 Feb 2022 10:53:56 EST</span><span class=\"mtk4\">\\n</span><span class=\"mtk6\">&quot;</span></span></span></code></pre>\n<p class=\"markdown-para\">Notice the output of the system command is a string ending with the newline character <code>\\n</code>.</p>\n<p class=\"markdown-para\">This technique can also be used in a one-liner with the <code>-e</code> flag, but in this case, the backticks must be escaped, otherwise it will result in a syntax error:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">ruby -e &quot;\\`date\\`&quot;</span></span></code></pre>\n<p class=\"markdown-para\">Unlike when running in IRB, there is no output from the above. This is because the Ruby code passed via the <code>-e</code> flag is not running any command that would output something to the console like <code>puts</code>. If you wanted to see the output of the system <code>date</code> command returned to the console:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">ruby -e &quot;puts \\`date\\`&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"># Outputs something like: Mon 21 Feb 2022 11:09:13 EST</span></span></code></pre>\n<h3 class=\"markdown-sub-subtitle\" id=\"regex\" style=\"position:relative;\"><a href=\"#regex\" aria-label=\"regex permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Regex</h3>\n<p class=\"markdown-para\">Next we're going to focus on what the first Ruby one liner is executing in the script:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">id=</span><span class=\"mtk6\">$(echo $(ruby -e &quot;</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\">nomad status myapp</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\"> =~ /^(\\w+)\\s+\\w+\\s+sidekiq.*/&quot; -e &quot;puts </span><span class=\"mtk4\">\\$</span><span class=\"mtk6\">1&quot;))</span></span></span></code></pre>\n<p class=\"markdown-para\">In the previous step, we learned that surrounding a system command with escaped backticks will run that command and return the string output of that command. In the case of the <code>nomad status myapp</code> command, this will be a multi-line string containing all of the job information and list of allocations.</p>\n<p class=\"markdown-para\">The next part of the command is the <code>=~</code> operator. This is the pattern matching operator in Ruby. It takes a string and a regular expression, and returns the index of the first occurrence where the regular expression matches in the string, or <code>nil</code> if there is no match. In Ruby, a regular expression can be denoted with forward slashes. So the general form of the <code>=~</code> operator is:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=~</span><span class=\"mtk1\"> </span><span class=\"mtk6\">/some_regex/</span></span></span></code></pre>\n<p class=\"markdown-para\">Let's look at a simple example. Suppose <code>some_string</code> contains just a single line from the <code>nomad status myapp</code> command, the line that lists the sidekiq allocation ID. Run the following from an IRB console:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=</span><span class=\"mtk1\"> </span><span class=\"mtk6\">&quot;d5353168  2008ce70  sidekiq     191      run      running  2d20h ago  2d20h ago&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=~</span><span class=\"mtk1\"> </span><span class=\"mtk6\">/sidekiq/</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk4\">20</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># 20 is the index of the first occurrence of the match `sidekiq` in some_string</span></span></span></code></pre>\n<p class=\"markdown-para\">Ultimately, we want to be able to extract the value of the allocation ID, which is the first sequence of letters and numbers in this string. The first thing to understand is that we can also match on <a href=\"https://www.regular-expressions.info/shorthand.html\" class=\"markdown-link\">Shorthand Character Classes</a>.</p>\n<p class=\"markdown-para\">For example, the <code>\\w</code> shorthand will match on any letter, number or underscore. The <code>\\s</code> shorthand will match on any whitespace including tabs, space character and newlines.</p>\n<p class=\"markdown-para\">Continuing in the IRB console with the previous example:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=~</span><span class=\"mtk1\"> </span><span class=\"mtk6\">/</span><span class=\"mtk4\">\\w</span><span class=\"mtk6\">/</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk4\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># some_string starts with a `d` which is a letter so first match is 0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=~</span><span class=\"mtk1\"> </span><span class=\"mtk6\">/</span><span class=\"mtk4\">\\s</span><span class=\"mtk6\">/</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk4\">8</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># first occurrence of a space character in some_string is at position 8</span></span></span></code></pre>\n<h3 class=\"markdown-sub-subtitle\" id=\"capture-group\" style=\"position:relative;\"><a href=\"#capture-group\" aria-label=\"capture group permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Capture Group</h3>\n<p class=\"markdown-para\">To extract a particular value from a string, we need to use a capture group. The syntax is to enclose the \"captured\" portion of the regex in parenthesis. The captured value is then available in a special variable <code>$1</code> (if there are multiple capture groups within a regex, then second value is available in special variable <code>$2</code> etc.). For example, to capture the first letter or number from our example string:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=~</span><span class=\"mtk1\"> </span><span class=\"mtk6\">/(</span><span class=\"mtk4\">\\w</span><span class=\"mtk6\">)/</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk4\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk6\">&quot;d&quot;</span></span></span></code></pre>\n<aside class=\"markdown-aside\">\nRetrieving the result of a capture group using the $1, $2 etc. special variables is fine for simple one-liners as in this example. However, if your program is more complicated, it's recommended to use the match method instead of the =~ operator, and use the resulting <a class=\"markdown-link\" href=\"https://rubyapi.org/3.1/o/matchdata\">MatchData</a> object that is returned.\n</aside>\n<p class=\"markdown-para\">To capture the first \"chunk\" of letters and numbers, up until a non letter/number character is encountered, add the <code>+</code> modifier to the shorthand character class which means match one or more:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"15\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=~</span><span class=\"mtk1\"> </span><span class=\"mtk6\">/(</span><span class=\"mtk4\">\\w</span><span class=\"mtk6\">+)/</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk4\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk6\">&quot;d5353168&quot;</span></span></span></code></pre>\n<p class=\"markdown-para\">This looks like what we need, the allocation ID of the sidekiq task. However, recall we set <code>some_string</code> to just one line within the output for demonstration purposes. The actual full output of the <code>nomad status myapp</code> command will be a larger string, composed of multiple lines separated by newline characters <code>\\n</code>.</p>\n<p class=\"markdown-para\">Something like this - I've split it up into separate lines for legibility but it would actually be one big string:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"\" data-index=\"16\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">&quot;Name          = myapp\\nType          = service\\nStatus        = running\\n</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">Allocations\\nID        Node ID   Task Group  Version  Desired  Status   Created    Modified\\n</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">0afe229d  2008ce70  puma        191      run      running  2d20h ago  2d20h ago\\n</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">fa39a002  2008ce70  puma        191      run      running  2d20h ago  2d20h ago\\n</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">8bd5fa5c  4163a6ca  puma        191      run      running  2d20h ago  2d20h ago\\n</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">d5353168  2008ce70  sidekiq     191      run      running  2d20h ago  2d20h ago\\n&quot;</span></span></code></pre>\n<p class=\"markdown-para\">This means the regex to capture only the sidekiq allocation id is a little more complicated. Describing it in English would read like:</p>\n<p class=\"markdown-para\">Find a line that starts with a series of letters and numbers, followed by a series of space characters, followed by another series of letters/numbers, followed by a series of space characters, followed by the word sidekiq, followed by any number of any characters, and then capture the first series of letters and numbers.</p>\n<p class=\"markdown-para\">To express this as a regex, let's break down that sentence into sections and write down the portion of the regex just for that part:</p>\n<ul class=\"markdown-list-unordered\">\n<li class=\"markdown-list-item\">Find a line that starts with a series of letters and numbers: <code>^\\w+</code> (caret <code>^</code>matches start of string)</li>\n<li class=\"markdown-list-item\">Followed by a series of space characters: <code>\\s+</code></li>\n<li class=\"markdown-list-item\">Followed by another series of letters/numbers: <code>\\w+</code></li>\n<li class=\"markdown-list-item\">Followed by a series of space characters: <code>\\s+</code></li>\n<li class=\"markdown-list-item\">Followed by the word sidekiq: <code>sidekiq</code></li>\n<li class=\"markdown-list-item\">Followed by any number of any characters: <code>.*</code> (dot <code>.</code> means any character, <code>*</code> means 0 or more times)</li>\n<li class=\"markdown-list-item\">And then capture the first series of letters and numbers: Add parents to first part: <code>^(\\w+)</code></li>\n</ul>\n<p class=\"markdown-para\">Putting this all together results in the following regex to be used in the script:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk6\">/^(</span><span class=\"mtk4\">\\w</span><span class=\"mtk6\">+)</span><span class=\"mtk4\">\\s</span><span class=\"mtk6\">+</span><span class=\"mtk4\">\\w</span><span class=\"mtk6\">+</span><span class=\"mtk4\">\\s</span><span class=\"mtk6\">+sidekiq.*/</span></span></span></code></pre>\n<p class=\"markdown-para\">Want to learn more about Ruby and Regex? Checkout this fantastic <a href=\"https://www.rubyguides.com/2015/06/ruby-regex/\" class=\"markdown-link\">tutorial</a>.</p>\n<h3 class=\"markdown-sub-subtitle\" id=\"chaining--multiple-one-liners\" style=\"position:relative;\"><a href=\"#chaining--multiple-one-liners\" aria-label=\"chaining  multiple one liners permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chaining  Multiple One Liners</h3>\n<p class=\"markdown-para\">Remember that to retrieve the result of a capture group requires a second line of code, to access the special variable <code>$</code>:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"ruby\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">some_string </span><span class=\"mtk7\">=~</span><span class=\"mtk1\"> </span><span class=\"mtk6\">/(</span><span class=\"mtk4\">\\w</span><span class=\"mtk6\">+)/</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk4\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">$1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">=&gt; </span><span class=\"mtk6\">&quot;d5353168&quot;</span></span></span></code></pre>\n<p class=\"markdown-para\">To get this effect in our script will require chaining together multiple <code>ruby -e</code> commands. The first command will execute the system command <code>nomad status myapp</code> and match it against the regex explained in the previous section. The second command will simply use the ruby <code>puts</code> command to output the value of the capture group in the <code>$1</code> special variable to the console. The dollar portion of the special variable must be escaped when run via <code>ruby -e</code>:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">ruby -e &quot;\\`nomad status myapp\\` =~ /^(\\w+)\\s+\\w+\\s+sidekiq.*/&quot; -e &quot;puts \\$1&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"># Outputs value in capture group, which is the sidekiq allocation ID: d5353168</span></span></code></pre>\n<h3 class=\"markdown-sub-subtitle\" id=\"converting-to-script-variable\" style=\"position:relative;\"><a href=\"#converting-to-script-variable\" aria-label=\"converting to script variable permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Converting to Script Variable</h3>\n<p class=\"markdown-para\">Now that the value of the sidekiq allocation ID has been output to the console, it has to get stored in a script variable. In other words, we're going to exit Ruby land and go back to Bash.</p>\n<p class=\"markdown-para\">The first step is to wrap the chain of ruby one liners in <code>echo $(...)</code> which runs it in a subshell and returns the value. Finally wrap that whole expression in another <code>$(...)</code> and assign the result to the <code>id</code> variable, which can then be used for the second command which is to run a shell in the sidekiq container:</p>\n<p class=\"markdown-para\">Putting this all together:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">id=</span><span class=\"mtk6\">$(echo $(ruby -e &quot;</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\">nomad status myapp</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\"> =~ /^(\\w+)\\s+\\w+\\s+sidekiq.*/&quot; -e &quot;puts </span><span class=\"mtk4\">\\$</span><span class=\"mtk6\">1&quot;))</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">nomad alloc </span><span class=\"mtk9\">exec</span><span class=\"mtk1\"> -i -t -task sidekiq $id /bin/bash</span></span></span></code></pre>\n<p class=\"markdown-para\">Finally, save these lines in a file with a shebang, usage, and comments. Remember to make the file executable:</p>\n<pre class=\"grvsc-container gatsby-highlight monokai\" data-language=\"bash\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">#!/bin/bash</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># USAGE: ./script/run-nomad-shell.sh</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Parse sidekiq allocation ID from status output, storing it in $id variable</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">id=</span><span class=\"mtk6\">$(echo $(ruby -e &quot;</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\">nomad status myapp</span><span class=\"mtk4\">\\`</span><span class=\"mtk6\"> =~ /^(\\w+)\\s+\\w+\\s+sidekiq.*/&quot; -e &quot;puts </span><span class=\"mtk4\">\\$</span><span class=\"mtk6\">1&quot;))</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># Run a shell in sidekiq allocation parsed from previous step</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">nomad alloc </span><span class=\"mtk9\">exec</span><span class=\"mtk1\"> -i -t -task sidekiq $id /bin/bash</span></span></span></code></pre>\n<p class=\"markdown-para\">Note that the <code>$1</code> is not a bash script variable, that's the result of the capture group from matching on the regex with ruby.</p>\n<h2 class=\"markdown-subtitle\" id=\"generalizing-the-example\" style=\"position:relative;\"><a href=\"#generalizing-the-example\" aria-label=\"generalizing the example permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generalizing the Example</h2>\n<p class=\"markdown-para\">The example in this post went into detail on my specific use case which was to capture a specific allocation ID from a Nomad status command, and then use that to launch a shell in that container. But this technique can be applied more generally anytime you want to run a system command, and then use the output from that command as input to a further command. The steps are:</p>\n<ul class=\"markdown-list-unordered\">\n<li class=\"markdown-list-item\">Run the first system command at your usual shell and write a regex with capture group that will capture the value you want from the output.</li>\n<li class=\"markdown-list-item\">Use <code>ruby -e</code> to run the first system command, matching on the regex you wrote in the previous step.</li>\n<li class=\"markdown-list-item\">Chain it with a second <code>ruby -e</code> to output the result of the capture group using the <code>$1</code> special variable.</li>\n<li class=\"markdown-list-item\">Wrap it with $(...), echo it, then one more $(...) wrap and assign to a script variable.</li>\n<li class=\"markdown-list-item\">Use the script variable in the next system command.</li>\n</ul>\n<h2 class=\"markdown-subtitle\" id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"markdown-header-link before\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p class=\"markdown-para\">This post has covered how Ruby can be used to run and parse system command output to automate tedious tasks where multiple commands and copy/pasting values are required. I hope you'll be able to apply this technique to speed up your workflows.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .monokai {\n    background-color: #272822;\n    color: #f8f8f2;\n  }\n  .monokai .mtk3 { color: #75715E; }\n  .monokai .mtk1 { color: #F8F8F2; }\n  .monokai .mtk9 { color: #66D9EF; }\n  .monokai .mtk6 { color: #E6DB74; }\n  .monokai .mtk4 { color: #AE81FF; }\n  .monokai .mtk7 { color: #F92672; }\n  .monokai .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","timeToRead":9,"tableOfContents":"<ul>\n<li>\n<p><a href=\"#the-problem\">The Problem</a></p>\n</li>\n<li>\n<p><a href=\"#script-solution\">Script Solution</a></p>\n<ul>\n<li><a href=\"#ruby-one-liners\">Ruby One Liners</a></li>\n<li><a href=\"#system-commands\">System Commands</a></li>\n<li><a href=\"#regex\">Regex</a></li>\n<li><a href=\"#capture-group\">Capture Group</a></li>\n<li><a href=\"#chaining--multiple-one-liners\">Chaining  Multiple One Liners</a></li>\n<li><a href=\"#converting-to-script-variable\">Converting to Script Variable</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#generalizing-the-example\">Generalizing the Example</a></p>\n</li>\n<li>\n<p><a href=\"#conclusion\">Conclusion</a></p>\n</li>\n</ul>","frontmatter":{"title":"Use Ruby to Parse Command Line Output","date":"01 Mar 2022","description":"Chain Ruby one-liners to parse command line output and execute system commands.","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/cfc1759ec375fe9d6af3555b984aae72/d730f/chain-ruby-one-liners-karine-avetisyan-ipuiM-36tAg-unsplash.jpg","srcSet":"/static/cfc1759ec375fe9d6af3555b984aae72/b834a/chain-ruby-one-liners-karine-avetisyan-ipuiM-36tAg-unsplash.jpg 225w,\n/static/cfc1759ec375fe9d6af3555b984aae72/21c52/chain-ruby-one-liners-karine-avetisyan-ipuiM-36tAg-unsplash.jpg 450w,\n/static/cfc1759ec375fe9d6af3555b984aae72/d730f/chain-ruby-one-liners-karine-avetisyan-ipuiM-36tAg-unsplash.jpg 900w","sizes":"(min-width: 900px) 900px, 100vw"},"sources":[{"srcSet":"/static/cfc1759ec375fe9d6af3555b984aae72/71a10/chain-ruby-one-liners-karine-avetisyan-ipuiM-36tAg-unsplash.webp 225w,\n/static/cfc1759ec375fe9d6af3555b984aae72/901f1/chain-ruby-one-liners-karine-avetisyan-ipuiM-36tAg-unsplash.webp 450w,\n/static/cfc1759ec375fe9d6af3555b984aae72/5acd1/chain-ruby-one-liners-karine-avetisyan-ipuiM-36tAg-unsplash.webp 900w","type":"image/webp","sizes":"(min-width: 900px) 900px, 100vw"}]},"width":900,"height":599}}}},"fields":{"slug":"/blog/ruby-parse-cli-output/"}},"relatedP":{"edges":[{"node":{"id":"d28e59ce-a5a4-5fb8-806f-c6d46d07ca4f","frontmatter":{"title":"How I Setup my Terminal","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#d8d8d8","images":{"fallback":{"src":"/static/c2e1140c0912270d2a20800e2b8aa88b/26528/terminal-cookie-the-pom-gySMaocSdqs-unsplash.jpg","srcSet":"/static/c2e1140c0912270d2a20800e2b8aa88b/26528/terminal-cookie-the-pom-gySMaocSdqs-unsplash.jpg 300w,\n/static/c2e1140c0912270d2a20800e2b8aa88b/43429/terminal-cookie-the-pom-gySMaocSdqs-unsplash.jpg 600w","sizes":"300px"},"sources":[{"srcSet":"/static/c2e1140c0912270d2a20800e2b8aa88b/5d6c3/terminal-cookie-the-pom-gySMaocSdqs-unsplash.webp 300w,\n/static/c2e1140c0912270d2a20800e2b8aa88b/68dbc/terminal-cookie-the-pom-gySMaocSdqs-unsplash.webp 600w","type":"image/webp","sizes":"300px"}]},"width":300,"height":170}}}},"fields":{"slug":"/blog/how-i-setup-my-terminal/"}}},{"node":{"id":"df308377-3f0e-5aae-8cce-4e9377304daa","frontmatter":{"title":"Solving a Python Interview Question in Ruby","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#080808","images":{"fallback":{"src":"/static/41cac534f5048f26531ee516516637b1/26528/python-interview-question.jpg","srcSet":"/static/41cac534f5048f26531ee516516637b1/26528/python-interview-question.jpg 300w,\n/static/41cac534f5048f26531ee516516637b1/43429/python-interview-question.jpg 600w","sizes":"300px"},"sources":[{"srcSet":"/static/41cac534f5048f26531ee516516637b1/5d6c3/python-interview-question.webp 300w,\n/static/41cac534f5048f26531ee516516637b1/68dbc/python-interview-question.webp 600w","type":"image/webp","sizes":"300px"}]},"width":300,"height":170}}}},"fields":{"slug":"/blog/python-interview-question-in-ruby/"}}},{"node":{"id":"c92d7f13-ff75-5632-be8c-e9b5ff992ddc","frontmatter":{"title":"Rails Feature Test Solved by Regex","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#487898","images":{"fallback":{"src":"/static/4b2924a3726801417360b49f81f7747b/26528/rails-feature-test-regex-patrick-tomasso-QMDap1TAu0g-unsplash.jpg","srcSet":"/static/4b2924a3726801417360b49f81f7747b/26528/rails-feature-test-regex-patrick-tomasso-QMDap1TAu0g-unsplash.jpg 300w,\n/static/4b2924a3726801417360b49f81f7747b/43429/rails-feature-test-regex-patrick-tomasso-QMDap1TAu0g-unsplash.jpg 600w","sizes":"300px"},"sources":[{"srcSet":"/static/4b2924a3726801417360b49f81f7747b/5d6c3/rails-feature-test-regex-patrick-tomasso-QMDap1TAu0g-unsplash.webp 300w,\n/static/4b2924a3726801417360b49f81f7747b/68dbc/rails-feature-test-regex-patrick-tomasso-QMDap1TAu0g-unsplash.webp 600w","type":"image/webp","sizes":"300px"}]},"width":300,"height":170}}}},"fields":{"slug":"/blog/rails-feature-test-solved-regex/"}}}]}},"pageContext":{"slug":"/blog/ruby-parse-cli-output/","relatedPosts":["Rails Feature Test Solved by Regex","Solving a Python Interview Question in Ruby","How I Setup my Terminal"]}},"staticQueryHashes":["163244226"],"slicesMap":{}}