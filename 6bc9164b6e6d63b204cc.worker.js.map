{"version":3,"file":"6bc9164b6e6d63b204cc.worker.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;;;;ACAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAqB;AAC7B;AACA;AACA;AACA,yCAAyC;AACzC,KAAK;AACL,GAAG;AACH;;AAEA;AACA,MAAM,KAAsB,EAAE,EAAM;;AAEpC;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,0CAA0C,6GAA6G,+BAA+B,sCAAsC,wCAAwC,6CAA6C,IAAI,MAAM,sCAAsC,0BAA0B,aAAa,kCAAkC,GAAG,sBAAsB,YAAY,KAAK,iCAAiC,YAAY,gBAAgB,aAAa,kBAAkB,cAAc,sBAAsB,qBAAqB,eAAe,wBAAwB,qCAAqC,aAAa,gCAAgC,GAAG,IAAI,EAAE,aAAa,4BAA4B,E","sources":["webpack://gatsby-starter-hello-world/webpack/bootstrap","webpack://gatsby-starter-hello-world/webpack/runtime/define property getters","webpack://gatsby-starter-hello-world/webpack/runtime/hasOwnProperty shorthand","webpack://gatsby-starter-hello-world/./src/workers/hello.worker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export function sayHello(href, referrer) {\n  const payload = {\n    guest_timezone_offset: new Date().getTimezoneOffset(),\n    user_agent: navigator.userAgent,\n    url: href,\n    referrer: referrer,\n  }\n  fetch(process.env.HELLO_URL, {\n    method: \"POST\",\n    body: JSON.stringify(payload),\n    headers: {\n      \"Content-type\": \"application/json; charset=UTF-8\",\n    },\n  })\n}\n\nonmessage = function(e) {\n  if (!process.env.HELLO_URL) return\n\n  let href, referrer\n  ;[href, referrer] = e.data\n  if (href) {\n    sayHello(href, referrer)\n  }\n}\n\naddEventListener(\"message\", function (e) {var _e$data = e.data,type = _e$data.type,method = _e$data.method,id = _e$data.id,params = _e$data.params,f,p;if (type === \"RPC\" && method) {if (f = __webpack_exports__[method]) {p = Promise.resolve().then(function () {return f.apply(__webpack_exports__, params);});} else {p = Promise.reject(\"No such method\");}p.then(function (result) {postMessage({type: \"RPC\",id: id,result: result});}).catch(function (e) {var message;try {message = e.message.toString();} catch (ex) {message = null;}var error = {message: message};if (e.stack) {error.stack = e.stack;error.name = e.name;}if (e.status) {error.status = e.status;error.responseJson = e.responseJson;}postMessage({type: \"RPC\",id: id,error: error});});}});postMessage({type: \"RPC\",method: \"ready\"});"],"names":[],"sourceRoot":""}